> Ask
> 注解@Autowired和@Resource的区别？
> @Auowired是如何注入的？

好的，这是一个非常经典的Spring框架面试题。

# 1. `@Autowired` 和 `Resource` 的区别

| 特性         | `@Autowired` (Spring)                      | `@Resource` (JSR-250)                     |
| :----------: | :----------------------------------------: | :----------------------------------------: |
| **来源**     | Spring框架原生注解 (`org.springframework.beans.factory.annotation`) | Java标准注解 (`javax.annotation`)，属于JSR-250规范 |
| **默认注入方式** | **按类型 (`byType`)**。容器查找匹配类型的唯一Bean进行注入。 | **按名称 (`byName`)**。容器查找与字段名/属性名/Setter方法参数名相同的Bean进行注入。 |
| **处理名称冲突** | 当存在多个同类型Bean时，需要配合 `@Qualifier("beanName")` 指定具体的Bean名称。 | 本身支持 `name` 属性 (`@Resource(name="myBean")`) 来显式指定Bean名称。 |
| **适用范围** | 可标注在**构造器、方法、参数、字段、注解**上。 | 可标注在**字段、Setter方法**上。**不能标注在构造器上**。 |
| **是否支持 `required`** | 支持。`@Autowired(required = false)` 表示依赖非必须，找不到Bean时注入`null`（避免抛出 `NoSuchBeanDefinitionException`）。 | **不支持**。如果找不到指定名称的Bean，一定会抛出异常。 |
| **依赖查找顺序** | 1. 按类型匹配 <br />2. 若有多个，按名称匹配（字段名/参数名）<br> 3. 若仍有歧义，需用 `@Qualifier` | 1. 按 `name` 属性指定名称匹配 <br> 2. 若未指定 `name`，则按字段名/属性名匹配 <br> 3. 若按名称未找到，则**回退到按类型匹配** |
| **主要优点** | Spring原生支持，与框架集成度高。支持更灵活的注入位置（如构造器）。 | 标准规范，不依赖特定框架（如也可用于Jakarta EE环境）。名称匹配更直观。 |

**关键区别总结：**

*   **来源不同：** `@Autowired` 是 Spring 专属，`@Resource` 是 Java 标准。
*   **默认策略不同：** `@Autowired` 默认按类型，`@Resource` 默认按名称。
*   **解决歧义方式不同：** `@Autowired` 依赖 `@Qualifier`，`@Resource` 自带 `name` 属性。
*   **构造器支持：** `@Autowired` 可以标注构造器，`@Resource` 不行。
*   **`required` 属性：** 只有 `@Autowired` 支持设置依赖是否必须。

# 2. `@Autowired` 是如何注入的？

`@Autowired` 的注入过程是 Spring IoC (Inversion of Control) 容器生命周期的一部分，核心在于 **`AutowiredAnnotationBeanPostProcessor`** 这个关键的 **`BeanPostProcessor`**。

以下是注入的详细步骤：

1.  **Bean 实例化：** Spring IoC 容器首先根据配置（XML、JavaConfig、ComponentScan）创建 Bean 的实例（通常通过反射调用构造器）。
2.  **依赖注入阶段 (Populate Properties)：** 在 Bean 实例化之后，但在其 `init` 方法（如 `@PostConstruct`）执行之前，容器会处理该 Bean 的依赖注入。
3.  **`BeanPostProcessor` 介入：** 容器会遍历所有注册的 `BeanPostProcessor`。`AutowiredAnnotationBeanPostProcessor` 是其中之一，它专门负责处理 `@Autowired` (以及 `@Value`, `@Inject`) 注解。
4.  **查找 `@Autowired` 注解：** `AutowiredAnnotationBeanPostProcessor` 会扫描当前正在初始化的 Bean 的：
    *   **字段 (Field)：** 被 `@Autowired` 标注的字段。
    *   **方法 (Method)：** 被 `@Autowired` 标注的方法（通常是 Setter 方法，但也可以是任意名称的方法）。方法的参数会被视为依赖。
    *   **构造器 (Constructor)：** 被 `@Autowired` 标注的构造器（或其参数）。如果只有一个构造器，通常可以省略 `@Autowired`。
5.  **依赖解析 (Dependency Resolution)：** 对于每个找到的需要注入的点（字段、方法参数、构造器参数），处理器会尝试从容器中解析依赖：
    *   **按类型 (`byType`)：** 这是默认策略。处理器查找容器中与依赖点类型（字段类型、方法参数类型、构造器参数类型）**匹配**的 Bean。
        *   **找到唯一 Bean：** 直接使用该 Bean。
        *   **找到多个同类型 Bean：**
            *   检查依赖点的**名称**（字段名、方法参数名）是否与某个候选 Bean 的名称匹配。如果匹配，则使用该 Bean。
            *   如果不匹配或仍有多个，则查找是否有 `@Qualifier` 注解指定了具体的 Bean 名称。使用 `@Qualifier` 指定的 Bean。
            *   如果以上都无法确定唯一 Bean，Spring 将抛出 `NoUniqueBeanDefinitionException`。
    *   **`@Qualifier` 的参与：** 如果字段、方法参数或构造器参数上同时标注了 `@Qualifier("beanName")`，处理器会优先按这个指定的名称 (`byName`) 去容器中查找 Bean，然后再结合类型进行校验。
    *   **`required` 属性：** 如果 `@Autowired(required = false)`，且容器中找不到匹配的 Bean，处理器会跳过这个注入点（字段保持 `null` 或 `java.util.Optional` 包装，方法/构造器参数传入 `null`），不会报错。默认为 `true`，找不到会抛出 `NoSuchBeanDefinitionException`。
6.  **依赖注入：**
    *   **字段注入：** 通过 Java 反射 (`Field.set(Object obj, Object value)`) 直接将解析到的 Bean 设置到目标字段上。**这会绕过字段的访问修饰符（如 `private`）。**
    *   **方法注入：** 通过反射调用被注解的方法 (`Method.invoke(Object obj, Object... args)`)，并将解析到的 Bean 作为参数传入。
    *   **构造器注入：** 在 Bean 实例化阶段就已经发生。容器会选择被 `@Autowired` 标注的构造器（或默认的唯一构造器），并通过反射调用它，将解析到的 Bean 作为构造器参数传入来创建实例。
7.  **完成：** 所有 `@Autowired` 注入点处理完毕后，该 Bean 的依赖注入阶段结束。容器接着会处理其他 `BeanPostProcessor`（如 `CommonAnnotationBeanPostProcessor` 处理 `@PostConstruct`）并执行初始化方法。

**核心机制总结：**

`@Autowired` 的注入是由 Spring 容器在 Bean 生命周期的 **依赖注入阶段**，通过专门的 **`AutowiredAnnotationBeanPostProcessor`** 利用 **Java 反射 (Reflection)** 机制实现的。它默认按类型查找依赖，结合名称匹配和 `@Qualifier` 解决歧义，并通过反射设置字段值或调用方法/构造器来完成注入。

**为什么理解这个过程重要？**

*   解释歧义错误 (`NoUniqueBeanDefinitionException`) 的原因和解决方法。
*   理解字段注入为什么能设置 `private` 字段（反射）。
*   明白构造器注入、Setter 注入、字段注入在 Spring 处理流程上的异同。
*   知道 `@Qualifier` 和 `required` 属性在注入流程中起作用的时机。
*   理解 Spring IoC 容器如何扩展（通过 `BeanPostProcessor`）来实现各种注解功能。



> Ask
>
> AutowiredAnnotationBeanPostProcessor处理器对@Autowired注解的处理核心代码在哪里

主要涉及以下几个关键类和方法：

## 核心类

1.  AutowiredAnnotationBeanPostProcessor

   > (位于 `org.springframework.beans.factory.annotation`包)

   - 这是处理 `@Autowired`、`@Value` 和 JSR-330 `@Inject` 注解的主要入口类。它实现了 `MergedBeanDefinitionPostProcessor` 和 `InstantiationAwareBeanPostProcessorAdapter` (或相关接口)，使其能在 Bean 生命周期的特定阶段介入。

## 核心方法 & 流程

处理流程主要围绕 `postProcessMergedBeanDefinition()` 和 `postProcessProperties()` 这两个方法：

1. **`postProcessMergedBeanDefinition(RootBeanDefinition beanDefinition, Class<?> beanType, String beanName)`**:

   - **目的：** 在 Bean 定义被合并之后、Bean 实例化**之前**执行。主要用于**查找**和**缓存**注入元数据 (`InjectionMetadata`)。
   - **核心动作**：
     - 调用 `findAutowiringMetadata(beanName, beanType, null)`。
     - `findAutowiringMetadata()` 会检查缓存中是否已有该 Bean 的注入元数据。如果没有，则调用 `buildAutowiringMetadata(clazz)` 进行构建。
     - `buildAutowiringMetadata(clazz)`
       - 使用反射遍历目标 Bean 类 (`clazz`) 及其所有父类。
       - 检查每个**字段 (Field)**：如果字段标注了 `@Autowired`、`@Value` 或 `@Inject`，则创建一个 `AutowiredFieldElement` 对象。
       - 检查每个**方法 (Method)**：如果方法标注了 `@Autowired`、`@Value` 或 `@Inject` (通常是 Setter，但不限于此)，则检查其参数。为每个需要注入的参数创建一个 `AutowiredMethodElement` 对象。
       - 将这些 `AutowiredFieldElement` 和 `AutowiredMethodElement` 对象收集起来，封装成一个 `InjectionMetadata` 对象。
     - 将构建好的 `InjectionMetadata` 对象缓存起来（键通常是 Bean 名称），避免每次注入都重新解析反射信息，提高性能。
   - **总结：** 此阶段负责**发现**哪些字段/方法需要注入，并**缓存**这些信息。

2. **`postProcessProperties(PropertyValues pvs, Object bean, String beanName)`**:

   - **目的：** 在 Bean 实例化之后、依赖注入阶段执行。这是**实际执行依赖查找和注入**的核心方法。

   - **核心动作：**

     - 从缓存中获取（或必要时构建）该 Bean 对应的 `InjectionMetadata` 对象。

     - 调用 `InjectionMetadata.inject(bean, beanName, pvs)`。

     - `InjectionMetadata.inject(...)` 方法会遍历其内部存储的所有 `InjectedElement` (即 `AutowiredFieldElement` 和 `AutowiredMethodElement`)。

     - 对每个  `InjectedElement` 调用其 `inject(...)` 方法：

       - 对于 `AutowiredFieldElement.inject(...)`：

         - 核心代码大致如下：

           ```java
           Field field = ... // 获取缓存的 Field 对象
           Object value;
           if (this.cached) {
               value = resolvedCachedArgument(beanName, this.cachedFieldValue);
           } else {
               // 关键点：解析依赖值
               DependencyDescriptor desc = new DependencyDescriptor(field, this.required);
               desc.setContainingClass(bean.getClass());
               value = beanFactory.resolveDependency(desc, beanName, autowiredBeanNames, typeConverter);
           }
           if (value != null) {
               // 关键点：反射注入
               ReflectionUtils.makeAccessible(field); // 确保可以访问 private 字段
               field.set(bean, value); // 将解析到的 value 设置到目标 bean 的 field 上
           }
           ```

         - `beanFactory.resolveDependency(...)` 是依赖解析的核心

           - 它根据 `DependencyDescriptor` (封装了字段类型、注解、是否必需等信息) 在 Spring 容器 (`BeanFactory`) 中查找匹配的 Bean。
           - 处理类型匹配、`@Qualifier`、`@Primary`、`@Priority`、自定义 `AutowireCandidateResolver` 等逻辑。
           - 处理集合/数组/Map 类型的注入。
           - 最终返回要注入的对象 (`value`)。

         - `ReflectionUtils.makeAccessible(field)` 确保即使字段是 `private` 也能访问。

         - `field.set(bean, value)` 使用反射将解析到的依赖对象 (`value`) 设置到目标 Bean 实例 (`bean`) 的对应字段上。

       - 对于 `AutowiredMethodElement.inject(...)`：

         - 逻辑类似，但针对方法：

           ```java
           Method method = ... // 获取缓存的方法对象
           Object[] arguments;
           if (this.cached) {
               arguments = resolveCachedArguments(beanName);
           } else {
               // 为方法的每个参数创建 DependencyDescriptor
               arguments = new Object[paramTypes.length];
               DependencyDescriptor[] descriptors = new DependencyDescriptor[paramTypes.length];
               for (int i = 0; i < arguments.length; i++) {
                   MethodParameter methodParam = new MethodParameter(method, i);
                   descriptors[i] = new DependencyDescriptor(methodParam, this.required);
                   descriptors[i].setContainingClass(bean.getClass());
               }
               // 关键点：解析所有参数依赖
               arguments = beanFactory.resolveDependencies(descriptors, beanName, autowiredBeanNames, typeConverter);
           }
           if (arguments != null) {
               // 关键点：反射调用方法进行注入
               ReflectionUtils.makeAccessible(method);
               method.invoke(bean, arguments); // 将解析到的参数 arguments 传入并调用目标方法
           }
           ```

         - 为方法的每个参数创建 `DependencyDescriptor`。

         - 调用 `beanFactory.resolveDependencies(...)` 批量解析所有参数依赖，得到参数值数组 `arguments`。

         - 使用反射 (`method.invoke(bean, arguments)`) 调用目标方法，将解析好的依赖作为参数传入，完成注入（通常是 Setter 方法，但也可以是任意方法）。

   - **总结：** 此阶段负责**解析**每个需要注入的字段或方法参数的依赖对象，并使用**反射**将值**注入**到目标 Bean 实例中。

**关键点总结：**

- **发现与缓存 (`postProcessMergedBeanDefinition`):** 利用反射找出所有标注了 `@Autowired` (等) 的字段和方法，构建并缓存 `InjectionMetadata`。
- **依赖解析 (`postProcessProperties` -> `resolveDependency`):** 对于每个需要注入的点，通过 `BeanFactory.resolveDependency()` 根据类型、名称(`@Qualifier`)、是否必需等条件从容器中查找匹配的 Bean。
- **反射注入 (`postProcessProperties` -> `Field.set()` / `Method.invoke()`):** 利用反射机制 (`java.lang.reflect`)，突破访问限制，将解析到的依赖对象设置到目标 Bean 的字段上或通过调用方法传入。

**建议查看的源码位置 (Spring Framework 5.x / 6.x):**

1. ```
   org.springframework.beans.factory.annotation.AutowiredAnnotationBeanPostProcessor
   ```

   - `postProcessMergedBeanDefinition()`
   - `postProcessProperties()`
   - `findAutowiringMetadata()`
   - `buildAutowiringMetadata()`

2. ```
   org.springframework.beans.factory.annotation.InjectionMetadata
   ```

   - `inject()`

3. ```
   org.springframework.beans.factory.annotation.AutowiredAnnotationBeanPostProcessor.AutowiredFieldElement
   ```

   - `inject()`

4. ```
   org.springframework.beans.factory.annotation.AutowiredAnnotationBeanPostProcessor.AutowiredMethodElement
   ```

   - `inject()`

5. ```
   org.springframework.beans.factory.support.DefaultListableBeanFactory
   ```

   - `resolveDependency()` (实际的依赖解析算法核心在这里)
   - `doResolveDependency()` (更底层的实现)

理解这些核心类和方法的交互，就能清晰地把握 `@Autowired` 注解背后的自动注入机制。调试 Spring 应用时在这些方法设置断点，是观察注入过程的绝佳方式。

> Ask
>
> 字段注入时, 使用@Autowried和@Resource都是使用反射直接注入吗

是的，**字段注入时，无论是使用 `@Autowired` 还是 `@Resource`，最终都是通过 Java 反射机制 `Field.set(Object obj, Object value)` 来直接设置字段值的。**

**详细解释：**

1.  **核心机制相同：**
    *   两者最终都依赖于 Java 的反射 API (`java.lang.reflect.Field`) 来访问和修改目标对象的字段，即使该字段是 `private` 的。
    *   在注入发生前，处理器都会调用 `ReflectionUtils.makeAccessible(field)`（或类似方法）来确保可以访问私有字段（本质上是调用 `field.setAccessible(true)`）。
    *   最终，都会调用 `field.set(beanInstance, resolvedDependency)` 将解析好的依赖对象赋值给目标 Bean 的对应字段。

2.  **处理它们的处理器不同：**
    *   **`@Autowired`：** 由 **`AutowiredAnnotationBeanPostProcessor`** 处理。该处理器负责扫描 `@Autowired`（以及 `@Value`, `@Inject`）注解。
    *   **`@Resource`：** 由 **`CommonAnnotationBeanPostProcessor`** 处理。该处理器负责扫描 JSR-250 注解，包括 `@Resource`, `@PostConstruct`, `@PreDestroy`。

3.  **依赖解析逻辑不同：**
    *   虽然注入动作本身都是反射 `field.set()`，但**如何找到要注入的值（依赖解析）** 的过程是不同的，这是它们的主要区别所在：
        *   **`@Autowired`：**
            *   默认按类型 (`byType`) 在 Spring 容器中查找匹配的 Bean。
            *   如果找到多个同类型 Bean，会尝试按字段名称匹配。
            *   如果仍有歧义，需要配合 `@Qualifier` 指定 Bean 名称。
            *   依赖解析的核心发生在 `AutowiredAnnotationBeanPostProcessor` 内部（最终委托给 `BeanFactory.resolveDependency()`）。
        *   **`@Resource`：**
            *   默认按名称 (`byName`) 查找。优先使用 `name` 属性指定的名称 (`@Resource(name="myBean")`)。
            *   如果未指定 `name`，则使用字段名（或属性名，对于 Setter 方法）作为 Bean 名称去查找。
            *   如果按名称找不到，则会**回退到按类型 (`byType`)** 查找。
            *   依赖解析的核心发生在 `CommonAnnotationBeanPostProcessor` 内部（最终也是委托给 `BeanFactory` 的方法，但查找策略遵循上述规则）。

4.  **注入阶段：**
    *   两者都是在 Bean 生命周期的 **“依赖注入阶段”**（在 Bean 实例化之后，初始化方法如 `@PostConstruct` 执行之前）进行处理。
    *   它们的 `BeanPostProcessor` 实现都会在 `postProcessProperties()` 方法（或早期版本中的 `postProcessPropertyValues()`）中执行实际的查找和注入操作。

**总结：**

| 特性             | `@Autowired` 字段注入                       | `@Resource` 字段注入                         |
| :--------------- | :------------------------------------------ | :------------------------------------------- |
| **最终注入方式** | **反射 `Field.set()`**                      | **反射 `Field.set()`**                       |
| **处理器**       | `AutowiredAnnotationBeanPostProcessor`      | `CommonAnnotationBeanPostProcessor`          |
| **默认解析策略** | **按类型 (`byType`)**                       | **按名称 (`byName`)** (字段名或 `name` 属性) |
| **名称解析**     | 需配合 `@Qualifier`                         | 内置 `name` 属性                             |
| **回退策略**     | 按类型失败则报错或置 `null` (看 `required`) | 按名称失败则**回退到按类型 (`byType`)**      |

**关键结论：**

*   **注入动作本身：** 两者在技术底层完全一致，都是利用 Java 反射的 `Field.set()` 方法直接设置字段值，无视访问修饰符。
*   **核心区别：** 在于**依赖查找和解析的策略**（按类型优先 vs 按名称优先+类型回退）以及负责处理它们的 Spring 内部组件 (`BeanPostProcessor`)。

因此，当你问“是否都是使用反射直接注入”时，答案是**肯定的**。反射 `Field.set()` 是它们实现字段注入的共同技术手段。它们的不同之处在于如何决定要把 *哪个对象* 通过反射设置进去。