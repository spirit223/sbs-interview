> Ask
> 讲讲Java类的加载过程


**类加载的过程**（也称为类的生命周期中的加载、连接、初始化阶段）主要分为以下几个步骤：

## 1.加载 (Loading)
*   **任务：** 查找并加载类的二进制字节码（通常是`.class`文件）到JVM内存中。
*   **谁来加载：** 由**类加载器 (ClassLoader)** 执行。类加载器遵循**双亲委派模型 (Parent Delegation Model)**：
    *   当一个类加载器收到加载类的请求时，它首先不会自己尝试加载，而是将这个请求**委派**给它的父类加载器。
    *   每一层的父类加载器都会尝试加载，只有当所有父类加载器都无法完成加载请求时（在自己的搜索路径中找不到该类），子加载器才会尝试自己去加载。
    *   主要的类加载器层次结构（从父到子）：
        *   **Bootstrap ClassLoader (启动类加载器):** 加载JRE核心库（如`rt.jar`, `charsets.jar`等），由C/C++实现，是JVM的一部分。它是所有类加载器的祖先。
        *   **Extension ClassLoader (扩展类加载器):** 加载JRE扩展目录（`jre/lib/ext`或由`java.ext.dirs`指定）中的JAR包。
        *   **System ClassLoader / Application ClassLoader (系统类加载器/应用类加载器):** 加载应用程序类路径（ClassPath）上的类库。这是开发者最常接触到的加载器。
        *   **自定义类加载器 (Custom ClassLoader):** 开发者可以继承`java.lang.ClassLoader`类创建自己的类加载器，实现特定的加载需求（如热部署、从网络加载、加密类文件等）。
*   **加载的结果：** 在JVM的方法区（或元空间）中创建一个代表这个类的`java.lang.Class`对象（作为该类各种数据访问的入口），同时在堆内存中生成对应的`Class`对象（供Java程序使用`getClass()`等方法获取）。

## 2.连接 (Linking)
*   连接阶段又可细分为三个子阶段：
    *   **验证 (Verification):**
        *   **目的：** 确保被加载的类的字节码是**合法、安全**的，符合JVM规范，不会危害虚拟机自身安全。
        *   **检查内容：** 文件格式验证（魔数、版本号）、元数据验证（语义分析，如是否有父类、是否继承final类）、字节码验证（数据流和控制流分析，确保指令逻辑合理）、符号引用验证（确保引用的类、字段、方法存在且可访问）。
    *   **准备 (Preparation):**
        *   **目的：** 为类的**静态变量**分配内存（在方法区/元空间），并设置**默认初始值**。
        *   **注意：**
            *   分配内存的是**类变量（static变量）**，不包括实例变量（实例变量在对象实例化时随对象一起分配在堆中）。
            *   设置的是**数据类型的默认值**，而不是程序代码中显式赋予的初始值。例如：
                *   `static int i;` 在准备阶段后 `i = 0`
                *   `static Object obj;` 在准备阶段后 `obj = null`
                *   对于`static final`修饰的**基本类型或String类型常量**（编译期可知），准备阶段会直接赋予**程序设定的常量值**（因为final在编译期就确定了）。
    *   **解析 (Resolution):**
        *   **目的：** 将类、接口、字段和方法的**符号引用 (Symbolic References)** 替换为**直接引用 (Direct References)**。
        *   **符号引用：** 一组描述被引用目标的符号（如全限定名），与内存布局无关。
        *   **直接引用：** 可以是直接指向目标的指针、相对偏移量或能间接定位到目标的句柄。解析就是将符号名（如`java/lang/Object`）转换成具体的内存地址或偏移量。
        *   **时机：** 解析可以在初始化之前完成，也可以在用到该符号引用时才完成（延迟解析/惰性解析）。

## 3.初始化 (Initialization)
*   **目的：** 执行类的**初始化代码**，主要是执行`<clinit>()`方法（类构造器方法）。
*   **`<clinit>()`方法：**
    *   由编译器自动收集类中**所有类变量的赋值动作**和**静态代码块 (`static{}`块)** 中的语句合并生成。
    *   顺序：按在源文件中出现的顺序执行。
    *   虚拟机会保证一个类的`<clinit>()`方法在多线程环境中被正确地加锁、同步（确保只执行一次）。
*   **触发时机：** 类在**首次主动使用**时会被初始化。主动使用的情况包括：
    *   创建类的实例 (`new`)
    *   访问类的静态变量（非常量 `static final`）或为静态变量赋值
    *   调用类的静态方法
    *   使用反射 (`Class.forName("com.example.Test")`)
    *   初始化一个类的子类（会先初始化父类）
    *   虚拟机启动时被标明为启动类的类（包含 `main()` 方法的类）
*   **注意：** 被动引用（如通过子类引用父类的静态字段）不会导致子类初始化。

## 总结关键点

*   **过程：** 加载 -> (验证 -> 准备 -> 解析) -> 初始化
*   **核心机制：** **双亲委派模型**（保证核心类库安全、避免重复加载）。
*   **重要阶段：**
    *   **准备阶段**：分配内存，设置静态变量**默认值**。
    *   **初始化阶段**：执行`<clinit>()`，设置静态变量**程序设定的初始值**，执行静态代码块。
*   **触发点：** 类的**首次主动使用**。

理解类加载过程有助于解释很多现象，比如为什么静态代码块只执行一次、静态变量的初始值问题、类冲突（NoClassDefFoundError, ClassNotFoundException）的排查、以及如何通过自定义类加载器实现特定功能等。