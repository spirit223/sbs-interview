> Ask
> Spring的事务传播级别有哪些?

# 事务传播级别
Spring 框架的事务传播行为定义了当一个事务方法被另一个事务方法调用时，事务应该如何传播。这是在处理复杂业务逻辑、涉及多个服务或方法调用时，确保数据一致性的关键机制。

Spring 定义了 7 种事务传播级别，都定义在 `org.springframework.transaction.annotation.Propagation` 枚举中

## 1.`PROPAGATION_REQUIRED` (Required - 默认级别)
**行为：** 如果当前存在事务，则加入该事务；如果当前没有事务，则创建一个新事务。
**理解：** 这是最常用的级别。它保证了方法总是在一个事务中运行。如果调用者已经在一个事务里，被调用的方法就加入这个事务（共享同一个物理事务）；如果调用者没有事务，被调用的方法就自己开启一个新事务。
**适用场景：** 绝大多数业务方法。它确保了操作的原子性。

## 2.`PROPAGATION_SUPPORTS` (Supports)
**行为：** 如果当前存在事务，则加入该事务；如果当前没有事务，则以非事务方式执行。
**理解：** 方法“支持”在事务中运行，但不强求。有事务就加入，没有事务就普通执行（没有事务保证）。
**适用场景：** 主要是查询操作（只读操作），这些操作不修改数据，在事务内或事务外执行都可以接受。或者某些方法逻辑在有事务时需一致性，没有时也能容忍不一致（较少见）。

## 3.`PROPAGATION_MANDATORY` (Mandatory)
**行为：** 如果当前存在事务，则加入该事务；如果当前没有事务，则抛出异常 (`IllegalTransactionStateException`)。
**理解：** 方法强制要求必须在一个现有的事务中运行。它自己不会创建事务。
**适用场景：** 被设计为必须作为更大事务一部分的方法。如果它被单独调用（没有事务上下文），则认为是编程错误。

## 4.`PROPAGATION_REQUIRES_NEW` (Requires New)
**行为：** 无论当前是否存在事务，总是创建一个新的事务。如果当前存在事务，则将当前事务挂起。
**理解：** 新事务是独立的。它有自己的提交和回滚，不受外部事务影响。外部事务会被暂停，直到新事务完成。
**适用场景：** 需要独立提交、不受外部事务成败影响的操作。例如，记录审计日志或发送通知（即使主业务失败，日志也要记下来）。

## 5.`PROPAGATION_NOT_SUPPORTED` (Not Supported)
**行为：** 总是以非事务方式执行。如果当前存在事务，则将当前事务挂起。
**理解：** 方法明确声明它不应该在事务中运行。它会挂起任何现有的事务。
**适用场景：** 方法不需要事务保证，或者方法内部的操作（如调用外部系统、某些特殊存储）与事务不兼容。性能优化（避免不必要的事务开销）也可能用到，但需谨慎。

## 6.`PROPAGATION_NEVER` (Never)
**行为：** 总是以非事务方式执行。如果当前存在事务，则抛出异常 (`IllegalTransactionStateException`)。
**理解：** 方法坚决拒绝在事务中运行。如果调用者有事务，直接报错。
**适用场景：** 确保方法绝对不会在事务上下文中执行，通常用于一些必须避免事务影响的操作。

## 7.`PROPAGATION_NESTED` (Nested)
**行为：** 如果当前存在事务，则在当前事务内创建一个嵌套事务（保存点）；如果当前没有事务，则其行为与 `PROPAGATION_REQUIRED` 一样（创建一个新事务）。
**理解：** 嵌套事务是外部事务的一部分。只有外部事务提交时，嵌套事务的修改才会最终提交。嵌套事务可以独立回滚（回滚到保存点），而不会导致整个外部事务回滚；但外部事务回滚会导致所有嵌套事务一起回滚。
**适用场景：** 处理事务内部的子任务，这些子任务可以独立失败而不影响整个事务（只要主逻辑能处理这种部分失败）。**注意：** 这个级别需要底层数据库（如 JDBC 驱动）支持保存点（Savepoint）才能生效。不是所有数据库或数据访问技术都支持。

**总结与关键点：**

**默认是 `PROPAGATION_REQUIRED`**，因为它能很好地保证原子性。
**`REQUIRES_NEW` 和 `NESTED` 的区别是核心难点：**
    `REQUIRES_NEW`：完全独立的新事务，与外部事务物理隔离。外部事务挂起。
    `NESTED`：是外部事务逻辑上的子集（保存点），依赖于外部事务。外部事务不挂起。
**`MANDATORY` 和 `NEVER`** 用于强制事务上下文的存在与否。
**`SUPPORTS`, `NOT_SUPPORTED`** 用于对事务依赖要求不高的场景。
选择哪个级别取决于具体的业务逻辑需求和事务边界的设计。
传播行为通常与事务的隔离级别 (`Isolation`) 一起配置。

面试官，这就是我对 Spring 事务传播级别的理解。在实际项目中，理解并正确配置传播行为对于构建健壮的事务管理至关重要。

# 事务如何保证原子性? Spring如何实现事务?
> Ask
> Spring 事务（注解式、编程式）如何保证原子性？spring如何实现的，如何进行恢复?

好的，面试官。Spring 事务管理（无论是注解式还是编程式）本身并不直接实现原子性，而是通过协调底层资源（主要是数据库连接）的事务机制来实现的。它提供了一套统一、抽象的 API 来管理事务的生命周期（开始、提交、回滚），并将这些操作与业务逻辑解耦。原子性的保证最终依赖于底层数据库（或其他支持事务的资源管理器）的能力。

下面详细解释注解式、编程式事务如何工作以及 Spring 如何实现原子性和恢复：

## 一、 事务管理方式

1.  **注解式事务管理 (`@Transactional`)**
    **原理：** 基于 Spring AOP (面向切面编程)。
    **工作流程：**
        1.  **代理创建：** Spring 容器在启动时，会为被 `@Transactional` 注解标记的类或方法创建代理对象（JDK 动态代理或 CGLIB 代理）。
        2.  **拦截调用：** 当客户端代码调用被代理对象的方法时，调用会被代理拦截。
        3.  **事务拦截器：** 代理将调用委托给一个事务拦截器（通常是 `TransactionInterceptor`）。
        4.  **事务管理：** `TransactionInterceptor` 是核心。它：
            根据注解属性（传播行为、隔离级别、超时、只读、回滚规则等）获取或创建一个事务（通过 `PlatformTransactionManager`）。
            将代表当前事务状态的对象（`TransactionStatus`）绑定到当前线程（通常使用 `ThreadLocal`）。
            **执行业务方法：** 调用原始目标对象的业务方法。
            **处理结果：**
                **成功：** 如果方法正常返回（无异常抛出），事务拦截器**提交**事务（调用 `PlatformTransactionManager.commit()`）。
                **失败：** 如果方法抛出**配置了需要回滚的异常**（默认是 `RuntimeException` 和 `Error`），事务拦截器**回滚**事务（调用 `PlatformTransactionManager.rollback()`）。
                **非回滚异常：** 如果抛出的是检查型异常或其他未配置为回滚的异常，事务拦截器会提交事务。
        5.  **清理资源：** 无论提交还是回滚，最终都会解除事务状态与线程的绑定，并执行必要的资源清理（如关闭连接，但通常连接会归还连接池）。
    **原子性保证：** 业务方法中的所有数据库操作（通过同一个 `DataSource` 获取的连接）都在同一个数据库事务上下文中执行。数据库保证这些操作要么全部成功（提交），要么全部无效（回滚）。Spring 通过正确地在方法执行前后触发事务的开始（获取连接，设置 `autoCommit=false`）和结束（提交/回滚）来确保这一点。

2.  **编程式事务管理 (`TransactionTemplate` 或 `PlatformTransactionManager` 直接操作)**
    **原理：** 开发者显式地在代码中控制事务边界。
    **核心类：** `TransactionTemplate` 是更常用的简化方式。
    **`TransactionTemplate` 工作流程 (`execute` 方法)：**
        1.  **定义逻辑：** 开发者将需要在事务中执行的代码封装在一个 `TransactionCallback` (通常用 lambda 表达式) 中。
        2.  **执行模板：** 调用 `transactionTemplate.execute(callback)`。
        3.  **内部管理：** `TransactionTemplate` 内部：
            根据自身配置的属性获取或创建一个新事务（通过其持有的 `PlatformTransactionManager`）。
            绑定事务状态到线程。
            **执行业务逻辑：** 执行传入的 `TransactionCallback` 中的代码 (`doInTransaction` 方法)。
            **处理结果：**
                如果 `doInTransaction` 正常返回，`TransactionTemplate` **提交**事务。
                如果 `doInTransaction` 抛出**未检查异常**（`RuntimeException` 或 `Error`），`TransactionTemplate` **回滚**事务。
                如果抛出**检查型异常**，默认情况下 `TransactionTemplate` **提交**事务（这与 `@Transactional` 默认行为不同！）。开发者可以通过重载的 `execute` 方法或自定义 `TransactionCallback` 实现来处理检查型异常的回滚逻辑。
            清理资源。
    **原子性保证：** 与注解式相同，`TransactionCallback` 中执行的数据库操作都在同一个数据库事务中，由数据库保证原子性。开发者通过 `TransactionTemplate` 正确地框定了事务的边界。

## 二、 Spring 如何实现（核心机制）

1.  **`PlatformTransactionManager` (平台事务管理器)**
    **角色：** Spring 事务抽象的核心接口。它是实际与底层事务资源（如 JDBC DataSource, JPA EntityManagerFactory, JTA 等）交互的组件。
    **关键方法：**
        `getTransaction(TransactionDefinition definition)`: 根据定义（传播行为、隔离级别等）获取一个事务（可能是新事务，也可能是已存在的事务），返回代表当前事务状态的 `TransactionStatus`。
        `commit(TransactionStatus status)`: 提交事务。
        `rollback(TransactionStatus status)`: 回滚事务。
    **常见实现：**
        `DataSourceTransactionManager`: 用于单个 JDBC `DataSource` 的本地事务管理。
        `JpaTransactionManager`: 用于 JPA (Hibernate 等) 的本地事务管理。
        `JtaTransactionManager`: 用于分布式事务管理（JTA），可以协调多个资源。

2.  **事务同步与资源绑定 (`TransactionSynchronizationManager`)**
    **角色：** 使用 `ThreadLocal` 变量来管理当前线程绑定的事务资源（如 JDBC Connection, Hibernate Session）和事务状态。
    **关键作用：**
        确保在同一个事务上下文中，多次通过 `DataSourceUtils.getConnection(dataSource)` (或框架的等效方法，如 `entityManagerFactory.getCurrentEntityManager()`) 获取到的是**同一个**物理连接（或 Session）。
        事务拦截器或 `TransactionTemplate` 在事务开始时绑定资源，在事务结束时解绑资源。
        支持注册 `TransactionSynchronization` 回调（在事务完成前后执行特定逻辑，如清除缓存）。

3.  **底层数据库连接管理**
    **获取连接：** `DataSourceTransactionManager` 通过 `DataSourceUtils.getConnection(dataSource)` 获取连接。这个方法会检查当前线程是否已绑定连接（在事务中），是则返回绑定连接，否则从连接池获取新连接。
    **事务设置：** 在事务开始时（`getTransaction` 内部），如果是一个新事务，会设置连接的 `autoCommit = false`。**这是实现原子性的关键一步！** 它告诉数据库后续操作属于一个逻辑单元。
    **提交/回滚：** `commit` 方法调用连接的 `commit()`；`rollback` 方法调用连接的 `rollback()`。这些操作最终由数据库执行。
    **释放连接：** 事务结束后（提交或回滚后），连接会被**归还给连接池**（通过 `DataSourceUtils.releaseConnection` 或等效操作），而不是直接关闭。连接池负责连接的复用。

## 三、 如何进行恢复（回滚）

1.  **触发条件：**
    **业务方法抛出异常：** 这是最常见的触发方式。Spring 事务管理器根据配置的**回滚规则**（默认：`RuntimeException` 和 `Error` 回滚，检查型异常提交）决定是否回滚。
    **显式标记回滚：** 在代码中调用 `TransactionAspectSupport.currentTransactionStatus().setRollbackOnly()` (注解式) 或 `TransactionStatus.setRollbackOnly()` (编程式)，无论是否抛出异常，最终都会回滚。
    **事务超时：** 如果事务执行时间超过配置的超时时间，事务管理器会主动回滚。
    **系统错误：** 如 JVM 崩溃，此时事务管理器来不及处理，恢复由数据库根据事务日志进行。

2.  **恢复过程：**
    **Spring 的角色：** 当决定回滚时，Spring 事务管理器（如 `DataSourceTransactionManager`）会调用当前数据库连接的 `rollback()` 方法。
    **数据库的角色：** **真正的恢复工作由数据库完成！** 数据库引擎利用其**事务日志**（如 Redo Log, Undo Log）：
        **Undo Log (回滚日志)：** 记录数据修改前的旧值。当收到 `rollback` 命令时，数据库根据 Undo Log 将数据恢复到事务开始前的状态。
        **Redo Log (重做日志)：** 主要用于保证事务的持久性（Durability），在崩溃恢复时重做已提交但未写入数据文件的操作。对于回滚操作，Redo Log 不是主要机制。
    **效果：** 在该事务内执行的所有 INSERT、UPDATE、DELETE 操作的效果都会被撤销，就像这些操作从未发生过一样。其他并发事务看到的数据状态是事务开始前或成功提交后的状态（取决于隔离级别）。

**总结：**

**原子性保证者：** 最终由底层数据库（或其他资源管理器）通过其事务机制实现。
**Spring 的角色：**
    提供统一的事务抽象（`PlatformTransactionManager`）。
    管理事务的生命周期（开始、提交、回滚）。
    通过 AOP（注解式）或模板（编程式）将事务管理与业务代码解耦。
    确保在同一事务上下文中使用正确的资源（连接/Session），通过 `ThreadLocal` 和 `TransactionSynchronizationManager` 实现。
    根据配置（传播行为、隔离级别、回滚规则等）协调事务行为。
**恢复机制：** Spring 在检测到需要回滚时调用数据库连接的 `rollback()` 方法。数据库利用其 Undo Log 撤销该事务的所有修改，实现原子性恢复。

理解 Spring 事务的核心在于理解它是对底层资源事务机制的协调者和抽象层，其原子性和恢复能力最终依赖于数据库本身。

> Ask
>
> 声明式事务失效场景和原因?

好的，面试官。声明式事务（主要是基于 `@Transactional` 注解）失效是一个在 Spring 应用中常见且容易踩坑的问题。理解其失效场景和根本原因对于开发和调试至关重要。以下是主要的失效场景及其原因分析：

**核心失效原因：Spring 的声明式事务是基于 AOP 代理实现的。** 事务功能由代理对象添加，而不是原始目标对象本身。任何绕过代理机制或干扰代理正常工作的行为都可能导致事务失效。

**常见失效场景及原因：**

1.  **方法访问修饰符非 `public`：**
    *   **原因：** Spring AOP 默认使用 JDK 动态代理（基于接口）或 CGLIB 代理（基于类）。对于非 `public` 方法（`protected`, `private`, `package-private`），**代理对象无法覆盖这些方法**。因此，调用这些方法时，事务拦截器 (`TransactionInterceptor`) 无法介入，事务逻辑（开启/提交/回滚）不会执行。
    *   **解决方案：** 确保被 `@Transactional` 注解标记的方法是 `public` 的。

2.  **在同一个类中，方法内部调用 `@Transactional` 方法：**
    *   **原因：** 这是最常见也最隐蔽的失效场景。假设类 `A` 中有方法 `a()` 和方法 `b()`（`b()` 被 `@Transactional` 注解）。当在 `a()` 内部直接调用 `this.b()` 时：
        *   调用 `a()` 的客户端代码是通过代理对象调用的（事务可能生效）。
        *   但在 `a()` 方法内部，`this` 指向的是**目标对象本身**，而不是代理对象。因此 `this.b()` 的调用**绕过了代理**，直接调用了原始目标对象的 `b()` 方法，事务拦截器没有机会介入，`b()` 的事务配置完全失效。
    *   **解决方案：**
        *   **重构代码：** 将 `b()` 方法抽取到另一个 Service 类中，然后通过注入该 Service 来调用 `b()`。这样调用必然通过代理。
        *   **使用 `AopContext.currentProxy()` (不推荐)：** 在 `a()` 中获取当前代理对象，然后通过代理调用 `b()`。这种方式侵入性强，且需要配置 `expose-proxy="true"`。
        *   **使用 `@Autowired` 注入自身 (不推荐)：** 在类 `A` 中 `@Autowired` 一个 `A` 类型的属性，然后在 `a()` 中通过这个属性调用 `b()`。这可能导致循环依赖等问题。

3.  **异常被 `catch` 住且未重新抛出（或抛出非回滚异常）：**
    *   **原因：** 事务的**回滚**是由事务拦截器在捕获到特定异常时触发的。
        *   **默认行为：** 只对 `RuntimeException` 和 `Error` 及其子类进行回滚。对检查型异常 (`Exception` 的子类但不是 `RuntimeException` 的子类) 默认**提交**事务。
        *   **问题场景：**
            *   方法内部 `try-catch` 了 `RuntimeException` 或 `Error`，并且没有在 `catch` 块中重新抛出异常或调用 `TransactionAspectSupport.currentTransactionStatus().setRollbackOnly()` 标记回滚。事务拦截器感知不到异常，会正常提交事务。
            *   方法抛出了一个检查型异常，但该异常类型**没有**在 `@Transactional(rollbackFor = MyCheckedException.class)` 中配置为需要回滚。事务拦截器认为这是正常结束，会提交事务。
    *   **解决方案：**
        *   确保需要回滚事务的异常（无论是运行时异常还是检查型异常）能够**传播**到事务拦截器。
        *   如果必须在方法内部处理某些异常，但又要回滚事务，在 `catch` 块中：
            *   要么重新抛出一个事务管理器配置为会回滚的异常类型（通常是 `RuntimeException`）。
            *   要么显式调用 `TransactionAspectSupport.currentTransactionStatus().setRollbackOnly()` 标记当前事务需要回滚。
        *   对于需要回滚的检查型异常，务必在 `@Transactional` 注解中明确指定 `rollbackFor` 属性。

4.  **数据库/数据库引擎本身不支持事务：**
    *   **原因：** Spring 事务管理最终依赖于底层资源的事务能力。如果使用的数据库存储引擎不支持事务（例如 MySQL 的 **MyISAM** 引擎），那么无论 Spring 如何配置，事务都不会生效（INSERT/UPDATE/DELETE 会立即生效）。
    *   **解决方案：** 确保数据库表使用的是支持事务的存储引擎（如 MySQL 的 **InnoDB**）。

5.  **未正确配置事务管理器 (`PlatformTransactionManager` Bean)：**
    *   **原因：** Spring 容器中必须存在一个 `PlatformTransactionManager` 类型的 Bean（如 `DataSourceTransactionManager`, `JpaTransactionManager`）。如果容器中没有这个 Bean，或者配置错误（例如未绑定正确的 `DataSource`），事务功能将无法启用。
    *   **解决方案：** 检查配置类或 XML 配置文件，确保正确声明并配置了事务管理器 Bean。

6.  **多数据源场景下未指定事务管理器：**
    *   **原因：** 当应用使用多个数据源时，通常会配置多个 `PlatformTransactionManager` Bean。`@Transactional` 注解默认使用名为 `transactionManager` 的 Bean。如果存在多个事务管理器但没有指定使用哪一个，或者使用的名字不是 `transactionManager` 且未通过 `@Transactional(transactionManager = "myTxManager")` 明确指定，会导致 Spring 无法确定使用哪个事务管理器，从而可能不生效或使用默认（可能错误）的事务管理器。
    *   **解决方案：**
        *   将主要的事务管理器 Bean 命名为 `transactionManager`。
        *   或者在每个 `@Transactional` 方法/类上明确指定要使用的事务管理器 Bean 的名称：`@Transactional(transactionManager = "mySpecificTxManager")`。

7.  **传播行为设置导致“看似失效”：**
    *   **原因：** 传播行为的配置可能导致事务行为不符合预期，容易被误认为失效。例如：
        *   `PROPAGATION_SUPPORTS`：如果当前没有事务，就以非事务方式运行。
        *   `PROPAGATION_NOT_SUPPORTED` / `PROPAGATION_NEVER`：强制以非事务方式运行或禁止在事务中运行。
        *   `PROPAGATION_REQUIRES_NEW`：虽然会开启新事务，但如果外部事务回滚，这个新事务因为独立提交了，其修改不会回滚（这有时是期望的，但有时会被误认为是外部事务没回滚它）。
    *   **解决方案：** 仔细检查并理解方法上配置的传播行为 (`propagation`) 是否符合业务逻辑的预期。

8.  **异步方法 (`@Async`) 中的事务：**
    *   **原因：** `@Async` 方法通常会在**不同的线程**中执行。Spring 的事务信息（如当前连接）是通过 `ThreadLocal` 绑定的。新线程无法继承原线程的 `ThreadLocal` 事务上下文，导致在新线程中执行的方法无法加入原有事务或开启新事务（除非特别处理）。
    *   **解决方案：** 在异步方法内部，如果需要事务，需要确保在该方法上**也**正确配置了 `@Transactional`，并且理解其传播行为（通常是 `REQUIRES_NEW`）。注意异步方法的事务边界是独立的。

9.  **方法被 `final` 或 `static` 修饰：**
    *   **原因（主要针对 CGLIB 代理）：** CGLIB 通过生成目标类的子类来创建代理。`final` 方法无法被子类覆盖，`static` 方法属于类而非实例，代理机制无法介入。
    *   **解决方案：** 避免在 `final` 或 `static` 方法上使用 `@Transactional`。如果使用 JDK 动态代理（基于接口），则 `final` 和 `static` 对接口方法无影响，但通常业务方法不会定义在接口上为 `static` 或 `final`。

**总结排查思路：**

1.  **检查方法修饰符：** 必须是 `public`。
2.  **检查调用方式：** 是否在同一个类内部调用？如果是，事务必然失效。
3.  **检查异常处理：** 是否 `catch` 了异常没抛出？抛出的异常是否是配置的回滚异常？
4.  **检查数据库引擎：** 是否是 InnoDB 等支持事务的引擎？
5.  **检查事务管理器配置：** Bean 是否存在？名称是否正确？数据源绑定是否正确？
6.  **检查传播行为：** 是否符合预期？
7.  **检查是否涉及异步：** 异步方法内的事务需要独立配置。
8.  **检查方法是否为 `final`/`static`：** （CGLIB 代理下）会导致失效。
