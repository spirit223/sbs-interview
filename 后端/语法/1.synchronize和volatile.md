> Ask
> 讲一下Syncronized关键字的底层实现原理。介绍一下偏向锁，轻量级锁。
> volatile有哪些作用？

好的，面试官。我来详细解释一下您提到的几个Java并发核心概念：

# 1. `synchronized` 关键字的底层实现原理

`synchronized` 是 Java 中实现线程同步、保证原子性和可见性的关键字。它的底层实现主要依赖于 **对象监视器锁（Monitor）** 和 **对象头（Object Header）** 中的 **Mark Word**。

*   **对象头与 Mark Word：** 每个 Java 对象在堆内存中都有一个对象头。对象头包含两部分信息：
    *   **Mark Word：** 存储对象自身的运行时数据（哈希码、GC分代年龄、**锁状态标志**、线程持有的锁、偏向线程ID等）。它的长度和具体内容会根据对象的状态（是否被锁定、是否偏向等）动态变化。
    *   **类型指针：** 指向对象所属类的元数据（Klass）的指针。
*   **Monitor（监视器锁）：** 可以理解为一个同步机制或同步对象。每个 Java 对象都与一个 Monitor 相关联（隐式关联）。Monitor 主要由以下几个部分组成：
    *   **Owner：** 记录当前持有该锁的线程。
    *   **Entry Set：** 当一个线程尝试获取已被其他线程持有的锁时，该线程会被阻塞并放入 Entry Set 中等待。
    *   **Wait Set：** 当持有锁的线程调用 `Object.wait()` 方法时，会释放锁并进入 Wait Set 等待被唤醒。
*   **加锁过程（重量级锁）：**
    1.  当线程进入 `synchronized` 修饰的代码块（方法）时，JVM 会尝试获取该对象关联的 Monitor。
    2.  如果 Monitor 的 Owner 为空，则当前线程成为 Owner，锁计数器加 1。
    3.  如果 Owner 已经是当前线程，锁计数器再次加 1（可重入）。
    4.  如果 Owner 是其他线程，当前线程会被阻塞，进入 Entry Set 等待，直到 Owner 线程释放锁（锁计数器减为 0）。
*   **释放锁过程：**
    1.  线程退出 `synchronized` 代码块（方法）时，锁计数器减 1。
    2.  当锁计数器减到 0 时，表示线程完全释放了锁。
    3.  JVM 会从 Entry Set 或 Wait Set 中唤醒一个等待线程来竞争锁（非公平策略是默认的）。

# 2. 偏向锁、轻量级锁（锁升级/锁膨胀）

为了减少获取锁和释放锁带来的性能开销（尤其是在无竞争或低竞争场景下），HotSpot JVM 实现了锁升级机制。锁的状态会随着竞争情况的变化而升级（膨胀），但不能降级。锁的状态主要存储在 Mark Word 中。

*   **无锁状态：** 对象刚被创建时的初始状态。
*   **偏向锁：**
    *   **目的：** 优化**同一个线程**多次进入同步块的场景。消除无竞争情况下的同步开销。
    *   **原理：**
        *   当一个线程第一次访问同步块时，JVM 会使用 CAS 操作将 Mark Word 中的线程 ID 设置为当前线程 ID，并将锁标志位设置为偏向模式。
        *   之后该线程再次进入这个同步块时，只需检查 Mark Word 中的线程 ID 是否指向自己：
            *   如果是，线程直接执行，无需任何同步操作（如 CAS、操作系统互斥）。
            *   如果不是（发生了竞争），说明至少有两个线程在竞争，偏向锁失效。
    *   **撤销：** 当发生竞争时，持有偏向锁的线程会被暂停，撤销偏向锁（恢复到无锁或标记为轻量级锁状态）。这个过程需要 STW（Stop-The-World），有一定开销。
    *   **适用场景：** 适用于只有一个线程反复访问同步块的场景。一旦有第二个线程访问，偏向锁通常会失效。
*   **轻量级锁：**
    *   **目的：** 优化**多个线程交替执行**同步块（不存在真正并发竞争）的场景。避免直接使用重量级锁带来的操作系统内核态切换开销。
    *   **原理：**
        *   当关闭偏向锁或偏向锁竞争失败后，JVM 会尝试升级为轻量级锁。
        *   线程在进入同步块之前，JVM 会在当前线程的栈帧中创建一个名为 **锁记录（Lock Record）** 的空间，用于存储锁对象当前的 Mark Word 拷贝（Displaced Mark Word）。
        *   JVM 使用 CAS 操作尝试将锁对象的 Mark Word 更新为指向该锁记录的指针。
            *   如果更新成功，该线程获得轻量级锁，锁标志位变为 `00`。
            *   如果更新失败（其他线程已持有该锁），JVM 会检查锁对象的 Mark Word 是否指向当前线程的栈帧：
                *   如果是，说明是重入，直接进入同步块执行。
                *   如果不是，说明存在竞争（多个线程尝试同时获取锁），轻量级锁膨胀为重量级锁。
    *   **解锁：** 使用 CAS 操作将 Displaced Mark Word 替换回对象头。
        *   如果成功，无竞争发生。
        *   如果失败，说明在持有锁期间发生了竞争（锁已膨胀），需要在释放重量级锁的同时唤醒被挂起的线程。
    *   **适用场景：** 线程交替执行同步块，不存在同一时间多个线程同时竞争锁的情况。如果存在并发访问，会膨胀为重量级锁。
*   **重量级锁：**
    *   当轻量级锁竞争失败（或本身就是高竞争场景），锁会膨胀为重量级锁。
    *   此时，Mark Word 中存储的是指向重量级锁（Monitor对象）的指针。
    *   后续线程尝试获取锁时，如果失败，会直接进入阻塞状态（被放入 Entry Set），需要操作系统的互斥量（mutex）支持，涉及用户态到内核态的切换，开销最大。

**锁升级路径：** `无锁 -> 偏向锁 -> 轻量级锁 -> 重量级锁`

# 3. `volatile` 关键字的作用

`volatile` 主要用于保证变量的**可见性**和**禁止指令重排序**。它提供了一种比 `synchronized` 更轻量级的同步机制。

*   **保证可见性：**
    *   **问题：** 在多线程环境下，每个线程都有自己的工作内存（CPU缓存）。一个线程修改了共享变量的值，可能只是先写入了自己的工作内存或缓存，还没有及时刷新回主内存。其他线程读取到的可能还是旧值。
    *   **作用：** 当一个变量被声明为 `volatile` 后：
        *   对该变量的**写操作**会**立即刷新到主内存**。
        *   对该变量的**读操作**会**从主内存中读取最新的值**（而不是使用工作内存/缓存中的副本）。
    *   这确保了当一个线程修改了 `volatile` 变量，其他线程能**立刻看到**这个修改。
*   **禁止指令重排序：**
    *   **问题：** 为了提高性能，编译器和处理器可能会对指令进行重排序（在不改变单线程执行结果的前提下）。但在多线程环境下，这种重排序可能导致程序出现不可预期的行为。
    *   **作用：** `volatile` 通过插入 **内存屏障（Memory Barrier）** 来限制指令重排序。
        *   在 `volatile` **写操作**之前插入 **StoreStore屏障**，之后插入 **StoreLoad屏障**。
        *   在 `volatile` **读操作**之后插入 **LoadLoad屏障** 和 **LoadStore屏障**。
    *   这些屏障确保了：
        *   `volatile` **写**之前的任何读写操作不会被重排序到**写**之后。
        *   `volatile` **读**之后的任何读写操作不会被重排序到**读**之前。
        *   `volatile` **写**操作与后续的 `volatile` **读**操作不会被重排序（保证了可见性）。
    *   这使得 `volatile` 变量能作为线程间安全发布对象的一种方式（例如单例模式的双重检查锁）。

**总结：**

*   `synchronized` 通过 Monitor 锁机制实现原子性和可见性，JVM 通过锁升级（偏向锁->轻量级锁->重量级锁）优化不同竞争场景下的性能。
*   `volatile` 通过强制读写主内存和内存屏障，提供轻量级的可见性和有序性保证，但不保证原子性（复合操作仍需 `synchronized` 或 `java.util.concurrent` 包中的原子类）。

面试官，以上就是我对 synchronized 底层原理、锁升级机制以及 volatile 作用的详细解释。